<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Homework Helper AI</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;500;700&display=swap" rel="stylesheet">
    
    <!-- Babel for in-browser compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body {
        font-family: 'Zen Maru Gothic', sans-serif;
        background-color: #f0f4f8;
      }
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #f1f1f1;
      }
      ::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #94a3b8;
      }
      @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-8px); }
        75% { transform: translateX(8px); }
      }
      .animate-shake {
        animation: shake 0.2s ease-in-out 0s 2;
      }
    </style>

    <!-- Import Map for Modules -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "@google/genai": "https://esm.sh/@google/genai@0.1.1",
    "react-dom/": "https://esm.sh/react-dom@^19.2.4/",
    "react/": "https://esm.sh/react@^19.2.4/"
  }
}
</script>
  </head>
  <body>
    <div id="root"></div>

    <!-- Main Application Script -->
    <script type="text/babel" data-type="module" data-presets="typescript,react">
      import React, { useState, useEffect, useRef } from 'react';
      import ReactDOM from 'react-dom/client';
      import { GoogleGenAI } from "@google/genai";

      // ----------------------------------------------------------------------
      // TYPES
      // ----------------------------------------------------------------------
      const Subject = {
        MATH: '数学',
        SCIENCE: '理科',
        HISTORY: '歴史/社会',
        ENGLISH: '英語',
        LITERATURE: '国語',
        PROGRAMMING: 'プログラミング',
        GENERAL: '一般'
      };

      const TargetLevel = {
        ELEMENTARY: '小学生',
        MIDDLE_SCHOOL: '中学生',
        HIGH_SCHOOL: '高校生',
        UNIVERSITY: '大学生/専門'
      };

      const Tone = {
        ENCOURAGING: '優しく丁寧に',
        DIRECT: '簡潔に答えのみ',
        SOCRATIC: 'ヒントを与えて考えさせる'
      };

      const OutputMode = {
        TEXT_EXPLANATION: '解説テキスト (推奨)',
        VISUAL_OVERLAY: '画像に書き込み (実験的)'
      };

      // ----------------------------------------------------------------------
      // CONSTANTS
      // ----------------------------------------------------------------------
      const SUBJECT_OPTIONS = Object.values(Subject);
      const LEVEL_OPTIONS = Object.values(TargetLevel);
      const TONE_OPTIONS = Object.values(Tone);
      const MODE_OPTIONS = Object.values(OutputMode);

      const DEFAULT_SETTINGS = {
        subject: Subject.MATH,
        level: TargetLevel.MIDDLE_SCHOOL,
        tone: Tone.ENCOURAGING,
        mode: OutputMode.TEXT_EXPLANATION,
      };

      const PROGRESS_STAGES = {
        idle: 0,
        preview: 5,
        uploading: 10,
        analyzing: 40,
        solving: 70,
        completed: 100,
        error: 0,
      };

      const SETTING_DESCRIPTIONS = {
        subject: "AIがどの専門知識を使って問題を解くかを決定します。",
        level: "解説の難易度や使われる用語を調整します。",
        tone: "AI先生の性格を決めます。「ヒント」は答えをすぐ知りたい場合には不向きです。",
        mode: "「画像に書き込み」は計算式などを画像上に直接描画しますが、生成に時間がかかります。"
      };

      // Security Configuration
      const APP_PASSCODE = "2024"; 
      const AUTH_STORAGE_KEY = "homework_helper_auth_token_v1";
      // Provided by user request
      const API_KEY = "AIzaSyDwQ_C3QufoHt8WvVOPPYRNP-o1NPfvZYM";

      // ----------------------------------------------------------------------
      // SERVICES (Gemini)
      // ----------------------------------------------------------------------
      
      // Initialize client
      const ai = new GoogleGenAI({ apiKey: API_KEY });

      const fileToGenerativePart = async (file) => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => {
            const base64String = reader.result;
            const base64Data = base64String.split(',')[1];
            resolve(base64Data);
          };
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      };

      const solveHomework = async (
        imagesBase64,
        settings,
        mimeType = 'image/jpeg',
        customInstruction = ''
      ) => {
        const modelName = 'gemini-2.0-flash-exp'; // Using experimental flash for speed/multimodal

        let prompt = `
          You are an expert tutor specializing in ${settings.subject} for ${settings.level} students.
          
          Task: Analyze the provided image(s) of a homework problem.
          Tone: ${settings.tone}.
        `;

        if (customInstruction && customInstruction.trim() !== "") {
          prompt += `
            
            USER SPECIFIC INSTRUCTION:
            The user has explicitly asked for the following: "${customInstruction}"
            Please prioritize this instruction when generating the response.
          `;
        }

        if (settings.mode === OutputMode.VISUAL_OVERLAY) {
          prompt += `
            CRITICAL INSTRUCTION:
            The user wants to see the solution WRITTEN ON THE FIRST IMAGE itself.
            Return an edited version of the FIRST input image with the correct answers and key steps written clearly over it in a contrasting color (like Red or Blue).
            Also provide a brief text summary of the final answer.
          `;
        } else {
          prompt += `
            Please provide a clear, step-by-step text explanation.
            Use Markdown for formatting.
            If it is a math problem, use LaTeX for equations (wrapped in single $ for inline and double $$ for block).
            Structure the response as:
            1. **Problem Analysis**: Briefly state what the problem is asking.
            2. **Step-by-Step Solution**: Show the work clearly.
            3. **Final Answer**: State the result prominently.
            4. **Tip**: A helpful hint for future similar problems.
          `;
        }

        try {
          const parts = imagesBase64.map(data => ({
            inlineData: {
              mimeType: mimeType,
              data: data
            }
          }));
          
          parts.push({ text: prompt });

          const contents = { parts };

          const response = await ai.models.generateContent({
            model: modelName,
            contents: contents,
          });

          let explanationText = "";
          let generatedImageBase64 = null;

          if (response.candidates && response.candidates.length > 0) {
            const parts = response.candidates[0].content?.parts;
            
            if (parts) {
              for (const part of parts) {
                if (part.text) {
                  explanationText += part.text;
                }
                if (part.inlineData) {
                  generatedImageBase64 = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
                }
              }
            }
          }

          if (!explanationText && response.text) {
              explanationText = response.text;
          }

          return {
            text: explanationText,
            image: generatedImageBase64
          };

        } catch (error) {
          console.error("Gemini API Error:", error);
          throw error;
        }
      };

      // ----------------------------------------------------------------------
      // COMPONENTS
      // ----------------------------------------------------------------------

      // --- Button ---
      const Button = ({ 
        children, 
        variant = 'primary', 
        isLoading = false, 
        icon,
        className = '',
        disabled,
        ...props 
      }) => {
        const baseStyles = "inline-flex items-center justify-center px-6 py-3 rounded-xl font-bold transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed transform active:scale-95";
        
        const variants = {
          primary: "bg-gradient-to-r from-blue-600 to-indigo-600 text-white hover:from-blue-700 hover:to-indigo-700 shadow-lg shadow-blue-500/30 focus:ring-blue-500",
          secondary: "bg-white text-gray-700 border-2 border-gray-200 hover:bg-gray-50 focus:ring-gray-200",
          danger: "bg-red-500 text-white hover:bg-red-600 focus:ring-red-500",
          ghost: "bg-transparent text-gray-600 hover:bg-gray-100 hover:text-gray-900"
        };

        return (
          <button 
            className={`${baseStyles} ${variants[variant]} ${className}`}
            disabled={disabled || isLoading}
            {...props}
          >
            {isLoading ? (
              <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-current" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
            ) : icon ? (
              <span className="mr-2">{icon}</span>
            ) : null}
            {children}
          </button>
        );
      };

      // --- SettingsPanel ---
      const SettingsPanel = ({ settings, onChange, disabled }) => {
        const handleChange = (key, value) => {
          onChange({ ...settings, [key]: value });
        };

        return (
          <div className="bg-white/80 backdrop-blur-md rounded-2xl p-6 shadow-xl border border-white/50 space-y-6">
            <div className="flex items-center gap-2 mb-4">
              <svg className="w-6 h-6 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4" />
              </svg>
              <h2 className="text-xl font-bold text-gray-800">学習設定</h2>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {/* Subject */}
              <div>
                <label className="block text-sm font-semibold text-gray-700 mb-2">教科</label>
                <div className="relative">
                  <select
                    value={settings.subject}
                    onChange={(e) => handleChange('subject', e.target.value)}
                    disabled={disabled}
                    className="w-full appearance-none bg-indigo-50 border border-indigo-100 text-gray-800 py-3 px-4 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition-shadow cursor-pointer"
                  >
                    {SUBJECT_OPTIONS.map((opt) => (
                      <option key={opt} value={opt}>{opt}</option>
                    ))}
                  </select>
                  <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700">
                    <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                  </div>
                </div>
                <p className="text-xs text-gray-500 mt-1 ml-1">{SETTING_DESCRIPTIONS.subject}</p>
              </div>

              {/* Level */}
              <div>
                <label className="block text-sm font-semibold text-gray-700 mb-2">学年レベル</label>
                <div className="relative">
                  <select
                    value={settings.level}
                    onChange={(e) => handleChange('level', e.target.value)}
                    disabled={disabled}
                    className="w-full appearance-none bg-indigo-50 border border-indigo-100 text-gray-800 py-3 px-4 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition-shadow cursor-pointer"
                  >
                    {LEVEL_OPTIONS.map((opt) => (
                      <option key={opt} value={opt}>{opt}</option>
                    ))}
                  </select>
                  <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700">
                    <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                  </div>
                </div>
                <p className="text-xs text-gray-500 mt-1 ml-1">{SETTING_DESCRIPTIONS.level}</p>
              </div>

              {/* Tone */}
              <div>
                <label className="block text-sm font-semibold text-gray-700 mb-2">解説のスタイル</label>
                <div className="relative">
                  <select
                    value={settings.tone}
                    onChange={(e) => handleChange('tone', e.target.value)}
                    disabled={disabled}
                    className="w-full appearance-none bg-indigo-50 border border-indigo-100 text-gray-800 py-3 px-4 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition-shadow cursor-pointer"
                  >
                    {TONE_OPTIONS.map((opt) => (
                      <option key={opt} value={opt}>{opt}</option>
                    ))}
                  </select>
                  <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700">
                    <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                  </div>
                </div>
                <p className="text-xs text-gray-500 mt-1 ml-1">{SETTING_DESCRIPTIONS.tone}</p>
              </div>

              {/* Mode */}
              <div>
                <label className="block text-sm font-semibold text-gray-700 mb-2">出力モード</label>
                <div className="relative">
                  <select
                    value={settings.mode}
                    onChange={(e) => handleChange('mode', e.target.value)}
                    disabled={disabled}
                    className={`w-full appearance-none py-3 px-4 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition-shadow cursor-pointer border ${settings.mode === OutputMode.VISUAL_OVERLAY ? 'bg-purple-50 border-purple-200 text-purple-900' : 'bg-indigo-50 border-indigo-100 text-gray-800'}`}
                  >
                    {MODE_OPTIONS.map((opt) => (
                      <option key={opt} value={opt}>{opt}</option>
                    ))}
                  </select>
                  <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700">
                    <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                  </div>
                </div>
                <p className="text-xs text-gray-500 mt-1 ml-1">
                  {settings.mode === OutputMode.VISUAL_OVERLAY 
                   ? "※ 答えが直接画像に書き込まれます（生成に時間がかかる場合があります）" 
                   : SETTING_DESCRIPTIONS.mode}
                </p>
              </div>
            </div>
          </div>
        );
      };

      // --- ImageUploader ---
      const ImageUploader = ({ onImagesSelected, disabled }) => {
        const [isDragging, setIsDragging] = useState(false);
        const fileInputRef = useRef(null);

        const handleDragOver = (e) => {
          e.preventDefault();
          if (!disabled) setIsDragging(true);
        };

        const handleDragLeave = (e) => {
          e.preventDefault();
          setIsDragging(false);
        };

        const handleDrop = (e) => {
          e.preventDefault();
          setIsDragging(false);
          if (disabled) return;
          
          if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
            validateAndProcess(Array.from(e.dataTransfer.files));
          }
        };

        const handleFileInput = (e) => {
          if (e.target.files && e.target.files.length > 0) {
            validateAndProcess(Array.from(e.target.files));
          }
        };

        const validateAndProcess = (files) => {
          const validFiles = files.filter(file => file.type.startsWith('image/'));
          
          if (validFiles.length === 0) {
            alert('画像ファイルを選択してください');
            return;
          }
          
          if (validFiles.length > 10) {
            alert('一度にアップロードできる画像は10枚までです');
            return;
          }

          onImagesSelected(validFiles);
        };

        return (
          <div
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
            onDrop={handleDrop}
            className={`
              relative group cursor-pointer
              border-4 border-dashed rounded-3xl p-10
              transition-all duration-300 ease-in-out
              flex flex-col items-center justify-center text-center
              min-h-[300px]
              ${isDragging 
                ? 'border-indigo-500 bg-indigo-50 scale-102 shadow-2xl' 
                : 'border-gray-200 bg-white hover:border-indigo-300 hover:bg-gray-50'
              }
              ${disabled ? 'opacity-50 cursor-not-allowed pointer-events-none' : ''}
            `}
            onClick={() => !disabled && fileInputRef.current?.click()}
          >
            <input
              type="file"
              ref={fileInputRef}
              onChange={handleFileInput}
              className="hidden"
              accept="image/*"
              multiple
              disabled={disabled}
            />

            <div className={`p-6 rounded-full bg-indigo-100 mb-4 transition-transform duration-300 ${isDragging ? 'scale-110 rotate-12' : 'group-hover:scale-110'}`}>
              <svg className="w-12 h-12 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
              </svg>
            </div>

            <h3 className="text-2xl font-bold text-gray-800 mb-2">
              画像をドロップ（複数可）
            </h3>
            <p className="text-gray-500 mb-6">
              または クリックしてファイルを選択<br/>
              <span className="text-xs text-indigo-400">※最大10枚まで</span>
            </p>

            <Button variant="secondary" onClick={(e) => { e.stopPropagation(); fileInputRef.current?.click(); }} disabled={disabled}>
              画像を選択する
            </Button>
          </div>
        );
      };

      // --- ProgressBar ---
      const ProgressBar = ({ progress, status }) => {
        const getStatusText = (status) => {
          switch (status) {
            case 'uploading': return '画像をアップロード中...';
            case 'analyzing': return 'AIが問題を読み取っています...';
            case 'solving': return '答えを導き出しています...';
            case 'completed': return '完了しました！';
            case 'error': return 'エラーが発生しました';
            default: return '待機中...';
          }
        };

        return (
          <div className="w-full max-w-lg mx-auto my-6 p-6 bg-white rounded-2xl shadow-lg">
            <div className="flex justify-between items-center mb-2">
              <span className="text-sm font-bold text-indigo-600 animate-pulse">
                {getStatusText(status)}
              </span>
              <span className="text-sm font-medium text-gray-500">{Math.round(progress)}%</span>
            </div>
            <div className="w-full bg-gray-100 rounded-full h-4 overflow-hidden">
              <div 
                className="bg-gradient-to-r from-blue-500 via-indigo-500 to-purple-500 h-4 rounded-full transition-all duration-500 ease-out"
                style={{ width: `${progress}%` }}
              >
                <div className="w-full h-full opacity-30 bg-[url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PHBhdHRlcm4gaWQ9InAiIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgcGF0dGVyblVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGggZD0iTTAgNDBMODAgMEgwTDQwIDBaIiBmaWxsPSIjZmZmIi8+PC9wYXR0ZXJuPjwvZGVmcz48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSJ1cmwoI3ApIi8+PC9zdmc+')] animate-[shimmer_1s_infinite_linear]"></div>
              </div>
            </div>
          </div>
        );
      };

      // --- ResultDisplay ---
      const ResultDisplay = ({ originalImages, processedImage, explanation, settings, feedback, onFeedback, onReset }) => {
        
        const handleShare = async () => {
          if (!explanation) return;
          
          const text = `【${settings.subject}のAI解説】\n\n${explanation}\n\n#宿題ヘルパーAI`;
          
          const shareData = {
              title: '宿題ヘルパーAIの結果',
              text: text,
          };

          if (processedImage && navigator.canShare) {
              try {
                  const fetchRes = await fetch(processedImage);
                  const blob = await fetchRes.blob();
                  const file = new File([blob], 'homework_solution.png', { type: 'image/png' });
                  
                  const filesData = { files: [file], title: shareData.title, text: shareData.text };
                  if (navigator.canShare(filesData)) {
                      shareData.files = [file];
                  }
              } catch (e) {
                  console.warn("Could not prepare image for sharing", e);
              }
          }

          try {
            if (navigator.share) {
              await navigator.share(shareData);
            } else {
              await navigator.clipboard.writeText(text);
              alert('解説テキストをクリップボードにコピーしました！友達に送ってあげましょう。'); 
            }
          } catch (error) {
            console.log('Share canceled or failed', error);
          }
        };

        const formatText = (text) => {
          const parts = text.split(/\*\*(.*?)\*\*/g);
          
          return parts.map((part, index) => {
            if (index % 2 === 1) {
              return <strong key={index} className="font-bold text-indigo-900 bg-indigo-50 px-1 rounded">{part}</strong>;
            }
            return part;
          });
        };

        return (
          <div className="animate-fade-in-up space-y-8">
            
            <div className="flex flex-col gap-6">
              <div className="bg-white rounded-2xl shadow-lg overflow-hidden border border-gray-100">
                 <div className="bg-gray-50 px-4 py-3 border-b border-gray-100 flex justify-between items-center">
                   <h3 className="font-bold text-gray-700">元の画像 ({originalImages.length}枚)</h3>
                 </div>
                 <div className="p-4 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 bg-gray-100/50">
                   {originalImages.map((img, idx) => (
                      <div key={idx} className="relative rounded-lg overflow-hidden border border-gray-200 shadow-sm bg-white">
                          <img src={img} alt={`Uploaded homework ${idx + 1}`} className="w-full h-auto object-contain" />
                      </div>
                   ))}
                 </div>
              </div>

              {settings.mode === OutputMode.VISUAL_OVERLAY && processedImage && (
                <div className="bg-white rounded-2xl shadow-lg overflow-hidden border border-purple-100 ring-2 ring-purple-100">
                   <div className="bg-purple-50 px-4 py-3 border-b border-purple-100 flex justify-between items-center">
                     <h3 className="font-bold text-purple-800">✨ AI解説付き画像</h3>
                   </div>
                   <div className="p-4 flex items-center justify-center bg-gray-100/50 min-h-[300px]">
                     <img src={processedImage} alt="Solved homework" className="max-h-[600px] w-auto object-contain rounded-lg shadow-sm" />
                   </div>
                </div>
              )}
            </div>

            {explanation && (
              <div className="bg-white rounded-2xl shadow-xl border border-indigo-100 overflow-hidden">
                <div className="bg-gradient-to-r from-indigo-600 to-blue-600 px-6 py-4 flex justify-between items-center">
                  <h3 className="text-xl font-bold text-white flex items-center">
                    <svg className="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                    </svg>
                    AI先生の解説
                  </h3>
                  
                  <button 
                    onClick={handleShare}
                    className="text-white/90 hover:text-white hover:bg-white/20 p-2 rounded-lg transition-colors"
                    title="解説をシェア・コピー"
                  >
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
                    </svg>
                  </button>
                </div>

                <div className="p-8 prose prose-indigo max-w-none prose-headings:font-bold prose-headings:text-indigo-800 prose-p:text-gray-700 prose-li:text-gray-700">
                  {explanation.split('\n').map((line, i) => {
                    if (line.startsWith('## ')) {
                      return <h2 key={i} className="text-2xl mt-4 mb-2">{formatText(line.replace('## ', ''))}</h2>;
                    }
                    if (line.startsWith('### ')) {
                      return <h3 key={i} className="text-xl mt-3 mb-2">{formatText(line.replace('### ', ''))}</h3>;
                    }
                    if (line.trim().startsWith('- ')) {
                        return <li key={i} className="ml-4 mb-1">{formatText(line.replace('- ', ''))}</li>
                    }
                    if (/^\d+\./.test(line.trim())) {
                        return <div key={i} className="ml-4 font-medium mt-1">{formatText(line)}</div>
                    }
                    return line.trim() ? <p key={i} className="mb-2 whitespace-pre-wrap leading-relaxed">{formatText(line)}</p> : <br key={i} />;
                  })}
                </div>

                <div className="bg-gray-50 p-4 border-t border-indigo-100 flex flex-col items-center gap-3">
                   <span className="text-sm font-bold text-gray-500">この解説は役に立ちましたか？</span>
                   <div className="flex gap-4">
                      <button
                        onClick={() => onFeedback('up')}
                        className={`flex items-center gap-2 px-4 py-2 rounded-full transition-all duration-200 border shadow-sm 
                          ${feedback === 'up' 
                            ? 'bg-green-100 border-green-300 text-green-700 scale-105' 
                            : 'bg-white border-gray-200 text-gray-500 hover:bg-gray-50 hover:text-green-600'
                          }`}
                      >
                        <svg className="w-5 h-5" fill={feedback === 'up' ? "currentColor" : "none"} stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L7 11v9m7-10h-2M7 20H5a2 2 0 01-2-2v-6a2 2 0 012-2h2.5" />
                        </svg>
                        <span>役に立った</span>
                      </button>
                      <button
                        onClick={() => onFeedback('down')}
                        className={`flex items-center gap-2 px-4 py-2 rounded-full transition-all duration-200 border shadow-sm
                          ${feedback === 'down' 
                            ? 'bg-red-100 border-red-300 text-red-700 scale-105' 
                            : 'bg-white border-gray-200 text-gray-500 hover:bg-gray-50 hover:text-red-600'
                          }`}
                      >
                        <svg className="w-5 h-5" fill={feedback === 'down' ? "currentColor" : "none"} stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 14H5.236a2 2 0 01-1.789-2.894l3.5-7A2 2 0 018.736 3h4.018a2 2 0 01.485.06l3.76.94m-7 10v5a2 2 0 002 2h.095c.5 0 .905-.405.905-.905 0-.714.211-1.412.608-2.006L17 13V4m-7 10h2m5-10h2a2 2 0 012 2v6a2 2 0 01-2 2h-2.5" />
                        </svg>
                        <span>いまいち</span>
                      </button>
                   </div>
                   {feedback && (
                     <span className="text-xs text-indigo-500 font-medium animate-fade-in">フィードバックありがとうございます！</span>
                   )}
                </div>
              </div>
            )}

            <div className="flex flex-col sm:flex-row justify-center gap-4 pt-4">
              <button 
                onClick={handleShare}
                className="flex items-center justify-center gap-2 px-8 py-4 bg-indigo-50 border-2 border-indigo-200 rounded-full font-bold text-indigo-700 hover:bg-indigo-100 hover:border-indigo-300 transition-all shadow-sm"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                   <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
                </svg>
                解説を友達に送る
              </button>

              <button 
                onClick={onReset}
                className="group flex items-center justify-center gap-2 px-8 py-4 bg-white border-2 border-gray-200 rounded-full font-bold text-gray-600 hover:border-indigo-400 hover:text-indigo-600 transition-all shadow-sm hover:shadow-md"
              >
                <svg className="w-5 h-5 transition-transform group-hover:-rotate-180" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                新しい問題を解く
              </button>
            </div>
          </div>
        );
      };

      // --- HistorySidebar ---
      const HistorySidebar = ({ history, isOpen, onClose, onSelectHistory, onClearHistory }) => {
        return (
          <>
            {isOpen && (
              <div 
                className="fixed inset-0 bg-black/50 z-40 transition-opacity"
                onClick={onClose}
              />
            )}

            <div className={`fixed top-0 right-0 h-full w-80 bg-white shadow-2xl z-50 transform transition-transform duration-300 ease-in-out ${isOpen ? 'translate-x-0' : 'translate-x-full'} overflow-y-auto`}>
              <div className="p-4 border-b border-gray-200 flex justify-between items-center bg-indigo-50">
                <h2 className="text-lg font-bold text-indigo-900">学習履歴</h2>
                <button onClick={onClose} className="text-gray-500 hover:text-gray-700">
                  <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
              </div>

              <div className="p-4 space-y-4">
                {history.length === 0 ? (
                  <div className="text-center text-gray-500 py-10">
                    <p>履歴はまだありません</p>
                  </div>
                ) : (
                  history.map((item) => (
                    <div 
                      key={item.id}
                      onClick={() => onSelectHistory(item)}
                      className="bg-white border border-gray-200 rounded-xl p-3 cursor-pointer hover:border-indigo-300 hover:shadow-md transition-all group"
                    >
                      <div className="flex justify-between items-start mb-2">
                        <span className="text-xs font-bold text-indigo-600 bg-indigo-50 px-2 py-1 rounded">
                          {item.settings.subject}
                        </span>
                        <span className="text-xs text-gray-400">
                          {new Date(item.timestamp).toLocaleDateString()}
                        </span>
                      </div>
                      
                      <div className="flex gap-2 mb-2 overflow-hidden h-16 bg-gray-100 rounded">
                          {item.originalImages.map((img, i) => (
                              <img key={i} src={img} className="h-full w-auto object-cover" alt="thumb" />
                          ))}
                      </div>
                      
                      {item.customInstruction && (
                         <div className="mb-2 p-1.5 bg-yellow-50 border border-yellow-100 rounded text-[10px] text-yellow-800 line-clamp-1">
                            <span className="font-bold">指示:</span> {item.customInstruction}
                         </div>
                      )}

                      <p className="text-xs text-gray-500 line-clamp-2">
                         {item.explanation?.substring(0, 60)}...
                      </p>
                    </div>
                  ))
                )}

                {history.length > 0 && (
                  <button 
                    onClick={() => {
                      if(window.confirm('本当にすべての履歴を消去しますか？')) {
                        onClearHistory();
                      }
                    }}
                    className="w-full mt-4 text-xs text-red-500 hover:text-red-700 underline text-center"
                  >
                    履歴をすべて消去
                  </button>
                )}
              </div>
            </div>
          </>
        );
      };

      // --- CanvasEditor ---
      const CanvasEditor = ({ imageSrc, onSave, onCancel }) => {
        const canvasRef = useRef(null);
        const containerRef = useRef(null);
        const [isDrawing, setIsDrawing] = useState(false);
        const [color, setColor] = useState('#EF4444'); 
        const [lineWidth, setLineWidth] = useState(3);
        
        useEffect(() => {
          const canvas = canvasRef.current;
          const ctx = canvas?.getContext('2d');
          const img = new Image();
          
          img.src = imageSrc;
          img.onload = () => {
            if (canvas && ctx && containerRef.current) {
              const maxWidth = Math.min(window.innerWidth - 40, 800);
              const maxHeight = window.innerHeight - 200;
              
              let width = img.width;
              let height = img.height;

              if (width > maxWidth || height > maxHeight) {
                const ratio = Math.min(maxWidth / width, maxHeight / height);
                width *= ratio;
                height *= ratio;
              }

              canvas.width = width;
              canvas.height = height;
              
              ctx.fillStyle = "white";
              ctx.fillRect(0, 0, width, height);
              ctx.drawImage(img, 0, 0, width, height);
              
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              ctx.strokeStyle = color;
              ctx.lineWidth = lineWidth;
            }
          };
        }, [imageSrc]);

        useEffect(() => {
          const canvas = canvasRef.current;
          const ctx = canvas?.getContext('2d');
          if (ctx) {
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
          }
        }, [color, lineWidth]);

        const startDrawing = (e) => {
          const canvas = canvasRef.current;
          if (!canvas) return;
          
          const ctx = canvas.getContext('2d');
          if (!ctx) return;

          setIsDrawing(true);
          const { x, y } = getCoordinates(e, canvas);
          ctx.beginPath();
          ctx.moveTo(x, y);
        };

        const draw = (e) => {
          if (!isDrawing) return;
          const canvas = canvasRef.current;
          if (!canvas) return;
          
          const ctx = canvas.getContext('2d');
          if (!ctx) return;
          
          const { x, y } = getCoordinates(e, canvas);
          ctx.lineTo(x, y);
          ctx.stroke();
        };

        const stopDrawing = () => {
          setIsDrawing(false);
          const canvas = canvasRef.current;
          const ctx = canvas?.getContext('2d');
          ctx?.closePath();
        };

        const getCoordinates = (e, canvas) => {
          const rect = canvas.getBoundingClientRect();
          let clientX, clientY;
          
          if ('touches' in e) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
          } else {
            clientX = e.clientX;
            clientY = e.clientY;
          }
          
          return {
            x: clientX - rect.left,
            y: clientY - rect.top
          };
        };

        const handleSave = () => {
          if (canvasRef.current) {
            onSave(canvasRef.current.toDataURL('image/jpeg', 0.9));
          }
        };

        return (
          <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
            <div className="bg-white rounded-2xl shadow-2xl w-full max-w-4xl flex flex-col max-h-[90vh]">
              
              <div className="p-4 border-b flex justify-between items-center">
                <h3 className="font-bold text-lg text-gray-800">画像を編集・書き込み</h3>
                <button onClick={onCancel} className="text-gray-500 hover:text-gray-700">
                  <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
              </div>

              <div 
                ref={containerRef} 
                className="flex-1 overflow-auto bg-gray-100 flex items-center justify-center p-4"
              >
                <canvas
                  ref={canvasRef}
                  onMouseDown={startDrawing}
                  onMouseMove={draw}
                  onMouseUp={stopDrawing}
                  onMouseLeave={stopDrawing}
                  onTouchStart={startDrawing}
                  onTouchMove={draw}
                  onTouchEnd={stopDrawing}
                  className="shadow-lg cursor-crosshair touch-none"
                />
              </div>

              <div className="p-4 bg-gray-50 border-t rounded-b-2xl flex flex-col sm:flex-row gap-4 justify-between items-center">
                
                <div className="flex gap-4 items-center">
                  <div className="flex gap-2 bg-white p-2 rounded-lg shadow-sm border border-gray-200">
                    {['#EF4444', '#3B82F6', '#10B981', '#F59E0B', '#000000'].map((c) => (
                      <button
                        key={c}
                        onClick={() => setColor(c)}
                        className={`w-6 h-6 rounded-full transition-transform hover:scale-110 ${color === c ? 'ring-2 ring-offset-2 ring-gray-400 scale-110' : ''}`}
                        style={{ backgroundColor: c }}
                      />
                    ))}
                  </div>

                  <div className="flex items-center gap-2 bg-white p-2 rounded-lg shadow-sm border border-gray-200">
                     <span className="text-xs text-gray-400">太さ</span>
                     <input 
                       type="range" 
                       min="1" 
                       max="10" 
                       value={lineWidth} 
                       onChange={(e) => setLineWidth(Number(e.target.value))}
                       className="w-20 accent-indigo-600"
                     />
                  </div>
                </div>

                <div className="flex gap-3 w-full sm:w-auto">
                  <Button variant="ghost" onClick={onCancel} className="flex-1 sm:flex-none">キャンセル</Button>
                  <Button onClick={handleSave} className="flex-1 sm:flex-none">保存する</Button>
                </div>
              </div>
            </div>
          </div>
        );
      };

      // --- AuthScreen ---
      const AuthScreen = ({ onLogin }) => {
        const [inputCode, setInputCode] = useState('');
        const [error, setError] = useState(false);
        const [isShake, setIsShake] = useState(false);

        const handleSubmit = (e) => {
          e.preventDefault();
          const success = onLogin(inputCode);
          if (!success) {
            setError(true);
            setIsShake(true);
            setTimeout(() => setIsShake(false), 500);
          }
        };

        return (
          <div className="min-h-screen bg-slate-50 flex items-center justify-center p-4 font-sans">
            <div className="fixed inset-0 overflow-hidden pointer-events-none z-0">
               <div className="absolute top-[-10%] left-[-10%] w-[500px] h-[500px] rounded-full bg-blue-200/20 blur-3xl"></div>
               <div className="absolute bottom-[-10%] right-[-10%] w-[500px] h-[500px] rounded-full bg-purple-200/20 blur-3xl"></div>
            </div>

            <div className="relative z-10 w-full max-w-md">
              <div className="bg-white/80 backdrop-blur-xl rounded-3xl shadow-2xl border border-white/50 p-8 text-center">
                
                <div className="mb-8 flex justify-center">
                  <div className="bg-gradient-to-tr from-indigo-600 to-purple-600 p-4 rounded-2xl shadow-lg">
                      <svg className="w-10 h-10 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
                      </svg>
                  </div>
                </div>

                <h1 className="text-2xl font-extrabold text-gray-800 mb-2">
                  Homework Helper AI
                </h1>
                <p className="text-gray-500 mb-8 text-sm">
                  このサービスを利用するには<br/>合言葉を入力してください。
                </p>

                <form onSubmit={handleSubmit} className="space-y-6">
                  <div className={`relative transition-transform ${isShake ? 'animate-shake translate-x-0' : ''}`}>
                    <input
                      type="password"
                      value={inputCode}
                      onChange={(e) => {
                          setInputCode(e.target.value);
                          setError(false);
                      }}
                      placeholder="合言葉 (Passcode)"
                      className={`w-full text-center text-2xl font-bold tracking-widest py-4 px-6 rounded-xl border-2 focus:outline-none focus:ring-4 transition-all
                        ${error 
                          ? 'border-red-300 bg-red-50 text-red-600 focus:ring-red-100 placeholder-red-300' 
                          : 'border-indigo-100 bg-indigo-50/50 text-gray-800 focus:border-indigo-500 focus:ring-indigo-100'
                        }`}
                      autoFocus
                    />
                  </div>
                  
                  {error && (
                      <p className="text-red-500 text-sm font-bold animate-fade-in">
                          合言葉が違います
                      </p>
                  )}

                  <Button type="submit" className="w-full py-4 text-lg">
                    ロックを解除
                  </Button>
                </form>

                <p className="mt-8 text-xs text-gray-400">
                  一度解除すると、この端末では次回から入力不要になります。
                </p>
              </div>
            </div>
          </div>
        );
      };

      // ----------------------------------------------------------------------
      // APP COMPONENT
      // ----------------------------------------------------------------------
      const HISTORY_STORAGE_KEY = 'homework_helper_history';

      const App = () => {
        // Authentication State
        const [isAuthenticated, setIsAuthenticated] = useState(false);
        const [isAuthChecking, setIsAuthChecking] = useState(true);

        const [settings, setSettings] = useState(DEFAULT_SETTINGS);
        const [isHistoryOpen, setIsHistoryOpen] = useState(false);
        const [history, setHistory] = useState([]);
        
        // Editor State
        const [editingImageIndex, setEditingImageIndex] = useState(null);

        const [state, setState] = useState({
          originalImages: [],
          processedImage: null,
          explanation: null,
          customInstruction: '', 
          feedback: null,
          status: 'idle',
          progress: 0,
        });

        // Check Authentication on Mount
        useEffect(() => {
          const storedAuth = localStorage.getItem(AUTH_STORAGE_KEY);
          if (storedAuth === 'true') {
            setIsAuthenticated(true);
          }
          setIsAuthChecking(false);
        }, []);

        // Load history on mount
        useEffect(() => {
          try {
            const saved = localStorage.getItem(HISTORY_STORAGE_KEY);
            if (saved) {
              setHistory(JSON.parse(saved));
            }
          } catch (e) {
            console.error("Failed to load history", e);
          }
        }, []);

        const handleLogin = (code) => {
          if (code === APP_PASSCODE) {
            localStorage.setItem(AUTH_STORAGE_KEY, 'true');
            setIsAuthenticated(true);
            return true;
          }
          return false;
        };

        // Save history helper
        const saveToHistory = (newItem) => {
          const updatedHistory = [newItem, ...history].slice(0, 10);
          setHistory(updatedHistory);
          try {
            localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(updatedHistory));
          } catch (e) {
            console.warn("Storage full, cannot save history", e);
          }
        };

        const updateHistoryItem = (id, updates) => {
          const updatedHistory = history.map(item => 
            item.id === id ? { ...item, ...updates } : item
          );
          setHistory(updatedHistory);
          try {
            localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(updatedHistory));
          } catch (e) {
            console.warn("Storage error", e);
          }
        };

        const clearHistory = () => {
          setHistory([]);
          localStorage.removeItem(HISTORY_STORAGE_KEY);
          setIsHistoryOpen(false);
        };

        // Handle fake progress
        useEffect(() => {
          let interval;
          if (['uploading', 'analyzing', 'solving'].includes(state.status)) {
            const target = PROGRESS_STAGES[state.status] || 0;
            interval = setInterval(() => {
              setState(prev => {
                if (prev.progress >= target + 25) return prev;
                return { ...prev, progress: Math.min(prev.progress + 1, 95) };
              });
            }, 100);
          }
          return () => clearInterval(interval);
        }, [state.status]);

        const handleImagesSelect = async (files) => {
          try {
            setState(prev => ({ ...prev, status: 'uploading', progress: 10, errorMessage: undefined, customInstruction: '', feedback: null, resultId: undefined }));
            
            const promises = files.map(async file => {
                const data = await fileToGenerativePart(file);
                return { data, type: file.type };
            });
            
            const fileData = await Promise.all(promises);
            const originalImageSrcs = fileData.map(f => `data:${f.type};base64,${f.data}`);

            setState(prev => ({ 
                ...prev, 
                originalImages: originalImageSrcs, 
                status: 'preview', 
                progress: 5 
            }));

          } catch (error) {
            console.error(error);
            setState(prev => ({ 
              ...prev, 
              status: 'error', 
              progress: 0, 
              errorMessage: "画像の読み込みに失敗しました。" 
            }));
          }
        };

        const handleSaveEditedImage = (newImageSrc) => {
          if (editingImageIndex === null) return;
          
          const newImages = [...state.originalImages];
          newImages[editingImageIndex] = newImageSrc;
          
          setState(prev => ({
            ...prev,
            originalImages: newImages
          }));
          setEditingImageIndex(null);
        };

        const handleRemoveImage = (index) => {
          const newImages = state.originalImages.filter((_, i) => i !== index);
          if (newImages.length === 0) {
            handleReset();
          } else {
            setState(prev => ({ ...prev, originalImages: newImages }));
          }
        };

        const handleStartAnalysis = async () => {
          if (state.originalImages.length === 0) return;

          try {
            setState(prev => ({ ...prev, status: 'analyzing', progress: 30 }));

            const base64Inputs = state.originalImages.map(src => src.split(',')[1]);
            const mimeType = state.originalImages[0].match(/:(.*?);/)?.[1] || 'image/jpeg';

            const result = await solveHomework(base64Inputs, settings, mimeType, state.customInstruction);
            
            setState(prev => ({ ...prev, status: 'solving', progress: 80 }));

            setTimeout(() => {
              const resultId = Date.now().toString();
              
              const finalState = { 
                ...state,
                status: 'completed', 
                explanation: result.text,
                processedImage: result.image,
                progress: 100,
                errorMessage: undefined,
                resultId: resultId,
                feedback: null
              };
              
              setState(finalState);

              saveToHistory({
                  id: resultId,
                  timestamp: Date.now(),
                  originalImages: state.originalImages,
                  processedImage: result.image,
                  explanation: result.text,
                  customInstruction: state.customInstruction,
                  settings: settings,
                  feedback: null
              });

            }, 800);

          } catch (error) {
            console.error(error);
            setState(prev => ({ 
              ...prev, 
              status: 'error', 
              progress: 0, 
              errorMessage: "AI解析中にエラーが発生しました。時間を置いて再度お試しください。" 
            }));
          }
        };

        const handleFeedback = (feedback) => {
          setState(prev => ({ ...prev, feedback }));
          if (state.resultId) {
            updateHistoryItem(state.resultId, { feedback });
          }
        };

        const handleReset = () => {
          setState({
            originalImages: [],
            processedImage: null,
            explanation: null,
            customInstruction: '',
            feedback: null,
            status: 'idle',
            progress: 0,
          });
        };

        const loadHistoryItem = (item) => {
          setSettings(item.settings);
          setState({
              originalImages: item.originalImages,
              processedImage: item.processedImage,
              explanation: item.explanation,
              customInstruction: item.customInstruction || '',
              status: 'completed',
              progress: 100,
              resultId: item.id,
              feedback: item.feedback || null
          });
          setIsHistoryOpen(false);
        };

        if (isAuthChecking) {
          return null;
        }

        if (!isAuthenticated) {
          return <AuthScreen onLogin={handleLogin} />;
        }

        return (
          <div className="min-h-screen bg-slate-50 text-slate-900 pb-20 font-sans">
            <div className="fixed inset-0 overflow-hidden pointer-events-none z-0">
               <div className="absolute top-[-10%] left-[-10%] w-[500px] h-[500px] rounded-full bg-blue-200/20 blur-3xl"></div>
               <div className="absolute top-[20%] right-[-5%] w-[400px] h-[400px] rounded-full bg-purple-200/20 blur-3xl"></div>
               <div className="absolute bottom-[-10%] left-[20%] w-[600px] h-[600px] rounded-full bg-indigo-200/20 blur-3xl"></div>
            </div>

            <div className="relative z-10 max-w-5xl mx-auto px-4 sm:px-6 lg:px-8">
              
              <header className="py-8 flex flex-col items-center justify-center text-center space-y-2 relative">
                 <button 
                   onClick={() => setIsHistoryOpen(true)}
                   className="absolute right-0 top-8 p-2 bg-white/80 rounded-full hover:bg-white shadow-sm transition-all text-indigo-600"
                   title="学習履歴"
                 >
                   <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                     <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                   </svg>
                 </button>

                <div className="bg-gradient-to-tr from-indigo-600 to-purple-600 p-3 rounded-2xl shadow-lg mb-2">
                  <svg className="w-10 h-10 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
                  </svg>
                </div>
                <h1 className="text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 to-purple-600 tracking-tight">
                  宿題ヘルパーAI
                </h1>
                <p className="text-lg text-gray-500 font-medium">
                  写真をとってアップロードするだけ。<br className="hidden sm:block" /> AIがあなたの専属家庭教師になります。
                </p>
              </header>

              <main className="space-y-10">
                
                {['idle', 'preview', 'completed'].includes(state.status) && (
                  <div className={`${state.status === 'completed' ? 'hidden' : 'block'} animate-fade-in`}>
                    <SettingsPanel 
                      settings={settings} 
                      onChange={setSettings} 
                      disabled={state.status !== 'idle' && state.status !== 'preview' && state.status !== 'completed'}
                    />
                  </div>
                )}

                {state.status === 'idle' && (
                  <div className="animate-fade-in-up delay-100">
                     <ImageUploader onImagesSelected={handleImagesSelect} />
                  </div>
                )}

                {state.status === 'preview' && (
                   <div className="animate-fade-in-up">
                      <div className="bg-white/80 backdrop-blur-md rounded-3xl p-8 shadow-xl border border-white/50 text-center">
                         <h2 className="text-2xl font-bold text-gray-800 mb-6">画像の確認・編集</h2>
                         <p className="text-gray-500 mb-6">問題の箇所を丸で囲むと、AIが認識しやすくなります。</p>
                         
                         <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
                            {state.originalImages.map((src, index) => (
                              <div key={index} className="relative group bg-gray-100 rounded-xl overflow-hidden shadow-sm border border-gray-200">
                                 <img src={src} alt="preview" className="w-full h-48 object-contain bg-white" />
                                 
                                 <div className="absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center gap-4">
                                    <button 
                                      onClick={() => setEditingImageIndex(index)}
                                      className="p-3 bg-white rounded-full text-indigo-600 hover:bg-indigo-50 hover:scale-110 transition-all shadow-lg"
                                      title="書き込み・編集"
                                    >
                                      <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                                      </svg>
                                    </button>
                                    <button 
                                      onClick={() => handleRemoveImage(index)}
                                      className="p-3 bg-white rounded-full text-red-500 hover:bg-red-50 hover:scale-110 transition-all shadow-lg"
                                      title="削除"
                                    >
                                      <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                      </svg>
                                    </button>
                                 </div>
                              </div>
                            ))}
                         </div>
                         
                         <div className="mb-8 text-left max-w-2xl mx-auto">
                           <label className="block text-sm font-bold text-gray-700 mb-2">
                             AIへの追加のお願い <span className="text-gray-400 font-normal">(任意)</span>
                           </label>
                           <textarea
                             value={state.customInstruction}
                             onChange={(e) => setState(prev => ({ ...prev, customInstruction: e.target.value }))}
                             placeholder="例：問2だけ解いてください / 途中式を小学生でもわかるように詳しく書いてください / 日本語訳だけ教えてください"
                             className="w-full px-4 py-3 rounded-xl border border-gray-300 focus:ring-2 focus:ring-indigo-500 focus:border-transparent min-h-[100px] resize-y bg-white/50"
                           />
                         </div>

                         <div className="flex flex-col sm:flex-row gap-4 justify-center">
                            <Button variant="secondary" onClick={handleReset}>キャンセル</Button>
                            <Button onClick={handleStartAnalysis} icon={
                              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" /></svg>
                            }>
                              この画像で解析する
                            </Button>
                         </div>
                      </div>
                   </div>
                )}

                {['uploading', 'analyzing', 'solving'].includes(state.status) && (
                  <div className="flex flex-col items-center justify-center py-20 animate-fade-in">
                    <div className="relative w-32 h-32 mb-8">
                       <div className="absolute inset-0 border-4 border-indigo-100 rounded-full"></div>
                       <div className="absolute inset-0 border-4 border-indigo-500 rounded-full border-t-transparent animate-spin"></div>
                       <div className="absolute inset-4 border-4 border-purple-100 rounded-full"></div>
                       <div className="absolute inset-4 border-4 border-purple-400 rounded-full border-b-transparent animate-spin-reverse"></div>
                    </div>
                    <ProgressBar progress={state.progress} status={state.status} />
                    <p className="text-gray-500 text-sm mt-4 text-center max-w-md">
                      画像の内容を解析し、{settings.subject}の専門知識を使って解説を作成しています...<br/>
                      {settings.mode === OutputMode.VISUAL_OVERLAY && "※ 画像生成モードは少し時間がかかります"}
                    </p>
                  </div>
                )}

                {state.status === 'error' && (
                  <div className="bg-red-50 border border-red-200 rounded-2xl p-8 text-center animate-shake">
                    <div className="inline-flex items-center justify-center w-16 h-16 rounded-full bg-red-100 mb-4">
                      <svg className="w-8 h-8 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                      </svg>
                    </div>
                    <h3 className="text-xl font-bold text-red-800 mb-2">エラーが発生しました</h3>
                    <p className="text-red-600 mb-6">{state.errorMessage || "予期せぬエラーです。"}</p>
                    <button 
                      onClick={handleReset}
                      className="px-6 py-2 bg-white border border-red-200 text-red-600 rounded-lg hover:bg-red-50 transition-colors font-bold"
                    >
                      もう一度やり直す
                    </button>
                  </div>
                )}

                {state.status === 'completed' && state.originalImages.length > 0 && (
                  <ResultDisplay 
                    originalImages={state.originalImages}
                    processedImage={state.processedImage}
                    explanation={state.explanation}
                    settings={settings}
                    feedback={state.feedback}
                    onFeedback={handleFeedback}
                    onReset={handleReset}
                  />
                )}

              </main>
              
              <footer className="mt-20 text-center text-gray-400 text-sm">
                <p>© 2024 Homework Helper AI. Powered by Google Gemini.</p>
              </footer>

              <HistorySidebar 
                 isOpen={isHistoryOpen} 
                 onClose={() => setIsHistoryOpen(false)}
                 history={history}
                 onSelectHistory={loadHistoryItem}
                 onClearHistory={clearHistory}
              />

              {editingImageIndex !== null && (
                <CanvasEditor 
                  imageSrc={state.originalImages[editingImageIndex]}
                  onSave={handleSaveEditedImage}
                  onCancel={() => setEditingImageIndex(null)}
                />
              )}

            </div>
          </div>
        );
      };

      // ----------------------------------------------------------------------
      // MOUNT
      // ----------------------------------------------------------------------
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);

    </script>
  </body>
</html>